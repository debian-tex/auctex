Common subdirectories: auctex-9.9p.orig/doc and auctex-9.9p/doc
Common subdirectories: auctex-9.9p.orig/style and auctex-9.9p/style
diff -u auctex-9.9p.orig/tex-jp.el auctex-9.9p/tex-jp.el
--- auctex-9.9p.orig/tex-jp.el	Thu Feb 11 19:19:49 1999
+++ auctex-9.9p/tex-jp.el	Sat Jul  3 11:53:22 1999
@@ -10,21 +10,48 @@
 
 ;;; Customization
 
-(setq TeX-format-list
-      (append '(("JLATEX" japanese-latex-mode
-		 "\\\\\\(documentstyle[^%\n]*{j\\|documentclass[^%\n]*{j\\)")
-		("JTEX" japanese-plain-tex-mode
-		 "-- string likely in Japanese TeX --"))
-	      TeX-format-list))
+;; TeX-format-list need to be set in tex.el
+;(setq TeX-format-list
+;      (append '(("JLATEX" japanese-latex-mode
+;		 "\\\\\\(documentstyle[^%\n]*{j\\|documentclass[^%\n]*{j\\)")
+;		("JTEX" japanese-plain-tex-mode
+;		 "-- string likely in Japanese TeX --"))
+;	      TeX-format-list))
 
+;; platex provided "platex" package is used by many Japanese users.
 (setq TeX-command-list
       (append (list (list "jTeX" "jtex '\\nonstopmode\\input %t'"
 			  'TeX-run-TeX nil t)
+		    (list "jLaTeX" "jlatex '\\nonstopmode\\input{%t}'"
+			  'TeX-run-LaTeX nil t)
 		    (list "pTeX" "ptex '\\nonstopmode\\input %t'"
                           'TeX-run-TeX nil t)
+		    (list "pLaTeX" "platex '\\nonstopmode\\input{%t}'"
+			  'TeX-run-LaTeX nil t)
 		    (list "jBibTeX" "jbibtex %s" 'TeX-run-BibTeX nil nil))
 	      TeX-command-list))
        
+;; the following code is needed to change mode-menu in japanese-LaTeX-mode.
+(easy-menu-define TeX-mode-menu
+    TeX-mode-map
+    "Menu used in TeX mode."
+  (append '("Command")
+	  '(("Command on"
+	     [ "Master File" TeX-command-select-master
+	       :keys "C-c C-c" :style radio
+	       :selected (eq TeX-command-current 'TeX-command-master) ]
+	     [ "Buffer" TeX-command-select-buffer
+	       :keys "C-c C-b" :style radio
+	       :selected (eq TeX-command-current 'TeX-command-buffer) ]
+	     [ "Region" TeX-command-select-region
+	       :keys "C-c C-r" :style radio
+	       :selected (eq TeX-command-current 'TeX-command-region) ]))
+	  (let ((file 'TeX-command-on-current))
+	    (mapcar 'TeX-command-menu-entry TeX-command-list))))
+
+(define-key LaTeX-mode-map [menu-bar Command] (cons "Command" TeX-mode-menu))
+;; up to here to change mode-menu in japanese-LaTeX-mode.
+
 (setq LaTeX-command-style
       (append (if (string-equal LaTeX-version "2")
 		  '(("^ams" "amsjlatex")
@@ -51,18 +78,32 @@
 	  (defvar TeX-japanese-process-output-coding-system 
 	    (find-coding-system 'junet)
 	    "TeX-process' coding system with standard output."))
-      (progn
-	(defvar TeX-japanese-process-input-coding-system *euc-japan*
-	  "TeX-process' coding system with standard input.")
-	(defvar TeX-japanese-process-output-coding-system *junet*
-	  "TeX-process' coding system with standard output."))))
+      (if (>= emacs-major-version 20)
+	  (progn
+	    (defvar TeX-japanese-process-input-coding-system 'euc-japan
+	      "TeX-process' coding system with standard input.")
+	    (defvar TeX-japanese-process-output-coding-system 'junet
+	      "TeX-process' coding system with standard output."))
+	(progn
+	  (defvar TeX-japanese-process-input-coding-system *euc-japan*
+	    "TeX-process' coding system with standard input.")
+	  (defvar TeX-japanese-process-output-coding-system *junet*
+	    "TeX-process' coding system with standard output.")))))
 
 (if (boundp 'NEMACS)
     (defvar TeX-process-kanji-code 2
       "TeX-process' kanji code with standard I/O.
 0:No-conversion  1:Shift-JIS  2:JIS  3:EUC/AT&T/DEC"))
 
-(defvar japanese-LaTeX-default-style "j-article"
+(defvar japanese-TeX-command-default "jTeX"
+  "The default command for TeX-command in the japanese-TeX mode.")
+(make-variable-buffer-local 'japanese-TeX-command-default)
+
+(defvar japanese-LaTeX-command-default "jLaTeX"
+  "The default command for TeX-command in the japanese-LaTeX mode.")
+(make-variable-buffer-local 'japanese-LaTeX-command-default)
+
+(defvar japanese-LaTeX-default-style "jarticle"
   "*Default when creating new Japanese documents.")
 (make-variable-buffer-local 'japanese-LaTeX-default-style)
 
@@ -243,7 +284,7 @@
 (defun japanese-plain-tex-mode-initialization ()
   "Japanese plain-TeX specific initializations."
   (if japanese-TeX-mode
-      (setq TeX-command-default "jTeX")))
+      (setq TeX-command-default japanese-TeX-command-default)))
 
 (add-hook 'LaTeX-mode-hook 'japanese-latex-mode-initialization)
 
@@ -259,6 +300,7 @@
   "Japanese LaTeX specific initializations."
   (if japanese-TeX-mode
       (progn
+	(setq TeX-command-default japanese-LaTeX-command-default)
 	(setq LaTeX-default-style japanese-LaTeX-default-style)
 	(setq LaTeX-style-list japanese-LaTeX-style-list)
 	(setq TeX-command-BibTeX "jBibTeX")
@@ -813,6 +855,297 @@
 	)
       (goto-char (point-max))
       (delete-horizontal-space)))))
+
+(if (string-lessp "20" emacs-version)
+;; This function is copied from 
+;; fill-region-as-paragraph in fill.el --- fill commands for Emacs
+;; Copyright (C) 1985, 86, 92, 94, 95, 96, 1997 Free Software Foundation, Inc.
+(defun LaTeX-fill-region-as-para-do (from to justify)
+  "Fill region as one paragraph: break lines to fit `fill-column'."
+  (setq x justify)
+  (unless (memq justify '(t nil none full center left right))
+    (setq justify 'full))
+  (setq y justify)
+  ;; Arrange for undoing the fill to restore point.
+  (if (and buffer-undo-list (not (eq buffer-undo-list t)))
+      (setq buffer-undo-list (cons (point) buffer-undo-list)))
+
+  ;; Make sure "to" is the endpoint.
+  (goto-char (min from to))
+  (setq to   (max from to))
+  ;; Ignore blank lines at beginning of region.
+  (skip-chars-forward " \t\n")
+
+  (let ((from-plus-indent (point))
+	(oneleft nil))
+
+    (beginning-of-line)
+    (setq from (point))
+  
+    ;; Delete all but one soft newline at end of region.
+    ;; And leave TO before that one.
+    (goto-char to)
+    (while (and (> (point) from) (eq ?\n (char-after (1- (point)))))
+      (if (and oneleft
+	       (not (and use-hard-newlines
+			 (get-text-property (1- (point)) 'hard))))
+	  (delete-backward-char 1)
+	(backward-char 1)
+	(setq oneleft t)))
+    (setq to (point))
+;;;     ;; If there was no newline, and there is text in the paragraph, then
+;;;     ;; create a newline.
+;;;     (if (and (not oneleft) (> to from-plus-indent))
+;;; 	(newline))
+    (goto-char from-plus-indent))
+
+  (if (not (> to (point)))
+      nil ; There is no paragraph, only whitespace: exit now.
+
+    (or justify (setq justify (current-justification)))
+
+    ;; Don't let Adaptive Fill mode alter the fill prefix permanently.
+    (let ((fill-prefix fill-prefix))
+      ;; Figure out how this paragraph is indented, if desired.
+      (if (and adaptive-fill-mode
+	       (or (null fill-prefix) (string= fill-prefix "")))
+	  (setq fill-prefix (fill-context-prefix from to)))
+
+      (save-restriction
+	(goto-char from)
+	(beginning-of-line)
+	(narrow-to-region (point) to)
+
+	(if (not justify)	    ; filling disabled: just check indentation
+	    (progn
+	      (goto-char from)
+	      (while (not (eobp))
+		(if (and (not (eolp))
+			 (< (current-indentation) (current-left-margin)))
+		    (LaTeX-indent-line))
+		(forward-line 1)))
+
+	  (if use-hard-newlines
+	      (remove-text-properties from (point-max) '(hard nil)))
+	  ;; Make sure first line is indented (at least) to left margin...
+	  (if (or (memq justify '(right center))
+		  (< (current-indentation) (current-left-margin)))
+	      (LaTeX-indent-line))
+	  ;; Delete the fill prefix from every line except the first.
+	  ;; The first line may not even have a fill prefix.
+	  (goto-char from)
+	  (let ((fpre (and fill-prefix (not (equal fill-prefix ""))
+			   (concat "[ \t]*"
+				   (regexp-quote fill-prefix)
+				   "[ \t]*"))))
+	    (and fpre
+		 (progn
+		   (if (>= (+ (current-left-margin) (length fill-prefix))
+			   (current-fill-column))
+		       (error "fill-prefix too long for specified width"))
+		   (goto-char from)
+		   (forward-line 1)
+		   (while (not (eobp))
+		     (if (looking-at fpre)
+			 (delete-region (point) (match-end 0)))
+		     (forward-line 1))
+		   (goto-char from)
+		   (if (looking-at fpre)
+		       (goto-char (match-end 0)))
+		   (setq from (point)))))
+	  ;; Remove indentation from lines other than the first.
+	  (beginning-of-line 2)
+	  (indent-region (point) (point-max) 0)
+	  (goto-char from)
+
+	  ;; FROM, and point, are now before the text to fill,
+	  ;; but after any fill prefix on the first line.
+
+	  ;; Make sure sentences ending at end of line get an extra space.
+	  ;; loses on split abbrevs ("Mr.\nSmith")
+	  (while (re-search-forward "[.?!][])}\"']*$" nil t)
+	    (or (eobp) (insert-and-inherit ?\ )))
+	  (goto-char from)
+	  ;; The character category `|' means that we can break a line
+	  ;; at the character.  Since we don't need a space between
+	  ;; them, delete all newlines between them ...
+	  (while (re-search-forward "\\c|\n\\|\n\\c|" nil t)
+	    (if (bolp)
+		(delete-char -1)
+	      (if (= (char-before (match-beginning 0)) ?\ )
+		  ;; ... except when there is end of sentence.  The
+		  ;; variable `sentence-end-double-space' is handled
+		  ;; properly later.
+		  nil
+		(delete-region (match-beginning 0) (1+ (match-beginning 0))))))
+	  (goto-char from)
+	  (skip-chars-forward " \t")
+	  ;; Then change all newlines to spaces.
+	  (subst-char-in-region from (point-max) ?\n ?\ )
+	  (if (not (eq justify 'full))
+	      nil
+	    (canonically-space-region (point) (point-max))
+	    (goto-char (point-max))
+	    (delete-horizontal-space)
+	    (insert-and-inherit " "))
+	  (goto-char (point-min))
+
+	  ;; This is the actual filling loop.
+	  (let ((prefixcol 0) linebeg)
+	    (while (not (eobp))
+	      (setq linebeg (point))
+	      (move-to-column (1+ (current-fill-column)))
+	      (if (eobp)
+		  (delete-horizontal-space)
+		;; Move back to the point where we can break the line
+		;; at.  We break the line between word or after/before
+		;; the character which has character category `|'.  We
+		;; search space, \c| followed by a character, or \c|
+		;; following a character.  If not found, place
+		;; the point at linebeg.
+		(if (re-search-backward " \\|\\c|.\\|.\\c|" linebeg 0)
+		    ;; In case of space, we place the point at next to
+		    ;; the point where the break occurs acutually,
+		    ;; because we don't want to change the following
+		    ;; logic of original Emacs.  In case of \c|, the
+		    ;; point is at the place where the break occurs.
+		    (forward-char 1))
+		;; Don't break after a period followed by just one space.
+		;; Move back to the previous place to break.
+		;; The reason is that if a period ends up at the end of a line,
+		;; further fills will assume it ends a sentence.
+		;; If we now know it does not end a sentence,
+		;; avoid putting it at the end of the line.
+		(while (or (and sentence-end-double-space
+				(> (point) (+ linebeg 2))
+				(eq (preceding-char) ?\ )
+				(not (eq (following-char) ?\ ))
+				(eq (char-after (- (point) 2)) ?\.)
+				(progn (forward-char -2) t))
+			   (and fill-nobreak-predicate
+				(funcall fill-nobreak-predicate)
+				(goto-char (match-beginning 0))))
+		  (if (re-search-backward " \\|\\c|.\\|.\\c|" linebeg 0)
+		      (forward-char 1)))
+		;; If the left margin and fill prefix by themselves
+		;; pass the fill-column. or if they are zero
+		;; but we have no room for even one word,
+		;; keep at least one word or a character which has
+		;; category `|'anyway .
+		;; This handles ALL BUT the first line of the paragraph.
+		(if (if (zerop prefixcol)
+			(save-excursion
+			  (skip-chars-backward " \t" linebeg)
+			  (bolp))
+		      (>= prefixcol (current-column)))
+		    ;; Ok, skip at least one word or one \c| character.
+		    ;; Meanwhile, don't stop at a period followed by one space.
+		    (let ((first t))
+		      (move-to-column prefixcol)
+		      (while (and (not (eobp))
+				  (or first
+				      (and (not (bobp))
+					   sentence-end-double-space
+					   (save-excursion (forward-char -1)
+							   (and (looking-at "\\. ")
+								(not (looking-at "\\.  ")))))
+				      (and fill-nobreak-predicate
+					   (funcall fill-nobreak-predicate))))
+			;; Find a breakable point while ignoring the
+			;; following spaces.
+			(skip-chars-forward " \t")
+			(if (looking-at "\\c|")
+			    (forward-char 1)
+			  (let ((pos (save-excursion
+				       (skip-chars-forward "^ \n\t")
+				       (point))))
+			    (if (re-search-forward "\\c|" pos t)
+				(forward-char -1)
+			      (goto-char pos))))
+			(setq first nil)))
+		  ;; Normally, move back over the single space between the words.
+		  (if (= (preceding-char) ?\ ) (forward-char -1))
+		  ;; Do KINSOKU processing.
+		  (if (and enable-multibyte-characters enable-kinsoku
+			   (save-excursion
+			     (goto-char (point-min))
+			     (skip-chars-forward "\0-\177")
+			     (/= (point) (point-max))))
+		      (kinsoku linebeg)))
+
+		;; If the left margin and fill prefix by themselves
+		;; pass the fill-column, keep at least one word.
+		;; This handles the first line of the paragraph.
+		(if (and (zerop prefixcol)
+			 (let ((fill-point (point)) nchars)
+			   (save-excursion
+			     (move-to-left-margin)
+			     (setq nchars (- fill-point (point)))
+			     (or (< nchars 0)
+				 (and fill-prefix
+				      (< nchars (length fill-prefix))
+				      (string= (buffer-substring (point) fill-point)
+					       (substring fill-prefix 0 nchars)))))))
+		    ;; Ok, skip at least one word.  But
+		    ;; don't stop at a period followed by just one space.
+		    (let ((first t))
+		      (while (and (not (eobp))
+				  (or first
+				      (and (not (bobp))
+					   sentence-end-double-space
+					   (save-excursion (forward-char -1)
+							   (and (looking-at "\\. ")
+								(not (looking-at "\\.  ")))))
+				      (and fill-nobreak-predicate
+					   (funcall fill-nobreak-predicate))))
+			;; Find a breakable point while ignoring the
+			;; following spaces.
+			(skip-chars-forward " \t")
+			(if (looking-at "\\c|")
+			    (forward-char 1)
+			  (let ((pos (save-excursion
+				       (skip-chars-forward "^ \n\t")
+				       (point))))
+			    (if (re-search-forward "\\c|" pos t)
+				(forward-char -1)
+			      (goto-char pos))))
+			(setq first nil))))
+		;; Check again to see if we got to the end of the paragraph.
+		(if (save-excursion (skip-chars-forward " \t") (eobp))
+		    (delete-horizontal-space)
+		  ;; Replace whitespace here with one newline, then indent to left
+		  ;; margin.
+		  (skip-chars-backward " \t")
+		  (if (and (= (following-char) ?\ )
+			   (or (aref (char-category-set (preceding-char)) ?|)
+			       (looking-at "[ \t]+\\c|")))
+		      ;; We need one space at end of line so that
+		      ;; further filling won't delete it.  NOTE: We
+		      ;; intentionally leave this one space to
+		      ;; distingush the case that user wants to put
+		      ;; space between \c| characters.
+		      (forward-char 1))
+		  (insert ?\n)
+		  ;; Give newline the properties of the space(s) it replaces
+		  (set-text-properties (1- (point)) (point)
+				       (text-properties-at (point)))
+		  (LaTeX-indent-line)
+		  ;; Set prefixcol so whitespace in the prefix won't get lost.
+		  (and fill-prefix (not (equal fill-prefix ""))
+                       (setq prefixcol (current-column)))))
+	      ;; Justify the line just ended, if desired.
+	      (if justify
+                (if (save-excursion (skip-chars-forward " \t") (eobp))
+                    (progn
+                      (delete-horizontal-space)
+                      (justify-current-line justify t t))
+		    (forward-line -1)
+		    (justify-current-line justify nil t)
+		    (forward-line 1))))))
+	;; Leave point after final newline.
+	(goto-char (point-max)))
+      (unless (eobp)
+	(forward-char 1))))))
 
 ;;; Support for various self-insert-command
 
diff -u auctex-9.9p.orig/tex.el auctex-9.9p/tex.el
--- auctex-9.9p.orig/tex.el	Thu Feb 11 19:19:47 1999
+++ auctex-9.9p/tex.el	Sat Jul  3 11:55:58 1999
@@ -1428,7 +1428,11 @@
 ;;; The Mode
 
 (defvar TeX-format-list
-  '(("AMSTEX" ams-tex-mode
+  '(("JLATEX" japanese-latex-mode
+     "\\\\\\(documentstyle[^%\n]*{j\\|documentclass[^%\n]*{j\\)")
+    ("JTEX" japanese-plain-tex-mode
+     "-- string likely in Japanese TeX --")
+    ("AMSTEX" ams-tex-mode
      "\\\\document\\b")
     ("LATEX" latex-mode 
      "\\\\\\(begin\\|section\\|chapter\\|documentstyle\\|documentclass\\)\\b")
